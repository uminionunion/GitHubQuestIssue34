# Docker Container and Hostinger VPS Connection Guide

## Table of Contents
1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Database Setup](#database-setup)
4. [SQLite Connection & Initialization](#sqlite-connection--initialization)
5. [Feature Implementation Details](#feature-implementation-details)
6. [Complete SQL Schema](#complete-sql-schema)
7. [Docker Container Setup](#docker-container-setup)
8. [Nginx Reverse Proxy Configuration](#nginx-reverse-proxy-configuration)
9. [Deployment Verification Checklist](#deployment-verification-checklist)

---

## Overview

This application is a full-stack Node.js/React web application running in a Docker container (`mainuhubfeaturev001`) on a Hostinger VPS. The application uses SQLite as its database and is reverse-proxied through Nginx to handle incoming web traffic.

### Key Components:
- **Frontend**: React 18 with TypeScript and Vite
- **Backend**: Express 5 with TypeScript
- **Database**: SQLite (file-based, no separate server needed)
- **Real-time Communication**: Socket.IO for chat functionality
- **Deployment**: Docker container with Nginx reverse proxy
- **Database Location**: `/home/app/data/database.sqlite`

---

## Architecture

### System Flow Diagram
```
User Browser (via Hostinger domain)
    â†“
Nginx Reverse Proxy (port 80/443)
    â†“
Docker Container "mainuhubfeaturev001" (port 4000)
    â†“
Express Server (port 4000 in production)
    â”œâ”€â”€ API Routes (/api/auth, /api/friends)
    â”œâ”€â”€ Socket.IO Server (Real-time chat)
    â””â”€â”€ Static File Server (React frontend)
         â†“
    SQLite Database (/home/app/data/database.sqlite)
```

### What Happens When User Visits Your Site:
1. User types your domain in browser (handled by Nginx)
2. Nginx reverse proxy forwards request to port 4000 inside Docker container
3. Express server receives request
4. If API request â†’ Express processes, queries SQLite database, returns JSON response
5. If page load â†’ Express serves built React frontend (static HTML/JS)
6. If WebSocket â†’ Socket.IO establishes real-time connection for chat

---

## Database Setup

### Database Location
```
/home/app/data/database.sqlite
```

The database file is created automatically on first run. The SQLite database is file-based, meaning:
- âœ… No separate database server needed
- âœ… Very lightweight (~few MB even with data)
- âœ… Automatically backed up if you backup `/home/app/data/`
- âœ… Perfect for production use on VPS

### Database Connection Code (server/db.ts)

```typescript
import { Kysely, SqliteDialect } from 'kysely';
import Database from 'better-sqlite3';
import type { DB } from './db-types.js';
import path from 'path';
import fs from 'fs';

// Get data directory from environment (for Docker) or use local 'data' folder
const dataDir = process.env.DATA_DIRECTORY || path.join(process.cwd(), 'data');

// Create data directory if it doesn't exist
if (!fs.existsSync(dataDir)) {
  fs.mkdirSync(dataDir, { recursive: true });
}

// Create path to database file
const dbPath = path.join(dataDir, 'database.sqlite');

// Connect to SQLite database using better-sqlite3 driver
const sqliteDb = new Database(dbPath);

// Create Kysely query builder instance for type-safe database operations
export const db = new Kysely<DB>({
  dialect: new SqliteDialect({
    database: sqliteDb,
  }),
  log: ['query', 'error'], // Log all queries and errors for debugging
});
```

### How It Works:
- **better-sqlite3**: Low-level SQLite driver (synchronous, very fast)
- **Kysely**: Query builder that prevents SQL injection and provides type safety
- **db-types.ts**: TypeScript definitions that match database schema (autocomplete in IDE!)
- **Automatic Creation**: Database file created at `/home/app/data/database.sqlite` on startup

---

## SQLite Connection & Initialization

### Environment Variables (In Docker)

The Docker container sets the environment variable:
```bash
DATA_DIRECTORY=/home/app/data
```

This tells the application where to store the database file.

### Database Initialization Process

When the application starts:

1. **Check if `/home/app/data/` exists**
   - If not, create it with `fs.mkdirSync()`
   
2. **Check if `database.sqlite` exists**
   - If it doesn't exist yet, better-sqlite3 creates it automatically
   
3. **Create database tables** (on first deployment)
   - You need to run the SQL initialization script once
   - After that, tables persist in the SQLite file

### Manual Database Initialization

If the database doesn't have tables, run this SQL script in a terminal inside the Docker container:

```bash
# Access Docker container shell
docker exec -it mainuhubfeaturev001 bash

# Navigate to app directory
cd /home/app

# Run node to execute SQL
node -e "
import('./dist/server/db.js').then(({ db }) => {
  // Tables will be created by running the SQL statements below
});
"
```

---

## Complete SQL Schema

All tables needed for the application are defined below. Run these SQL statements once to initialize the database:

```sql
-- ============================================
-- USERS TABLE
-- ============================================
-- Stores user account information
-- username: Unique username (all prefixed with 'u' like 'uJohn')
-- password: Hashed password (never stored plain text)
-- email: User email address
-- phone_number: User phone number
-- profile_image_url: URL to user's profile picture
-- cover_photo_url: URL to user's cover/banner photo
CREATE TABLE IF NOT EXISTS users (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  username TEXT NOT NULL UNIQUE,
  password TEXT NOT NULL,
  email TEXT UNIQUE,
  phone_number TEXT UNIQUE,
  profile_image_url TEXT,
  cover_photo_url TEXT
);

-- Indexes for faster lookups
CREATE UNIQUE INDEX IF NOT EXISTS idx_users_email ON users(email);
CREATE UNIQUE INDEX IF NOT EXISTS idx_users_phone_number ON users(phone_number);

-- ============================================
-- FRIENDS TABLE
-- ============================================
-- Manages friend relationships between users
-- status: Can be 'pending' (request sent) or 'accepted' (confirmed friends)
-- user_id1: Always the smaller ID (prevents duplicate entries)
-- user_id2: Always the larger ID (prevents duplicate entries)
CREATE TABLE IF NOT EXISTS friends (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id1 INTEGER NOT NULL,
    user_id2 INTEGER NOT NULL,
    status TEXT NOT NULL CHECK(status IN ('pending', 'accepted')) DEFAULT 'pending',
    FOREIGN KEY (user_id1) REFERENCES users(id),
    FOREIGN KEY (user_id2) REFERENCES users(id),
    UNIQUE(user_id1, user_id2)
);

-- ============================================
-- BLOCKED_USERS TABLE
-- ============================================
-- Stores user blocks (prevents communication)
-- blocker_id: User who blocked someone
-- blocked_id: User who got blocked
CREATE TABLE IF NOT EXISTS blocked_users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    blocker_id INTEGER NOT NULL,
    blocked_id INTEGER NOT NULL,
    FOREIGN KEY (blocker_id) REFERENCES users(id),
    FOREIGN KEY (blocked_id) REFERENCES users(id),
    UNIQUE(blocker_id, blocked_id)
);

-- ============================================
-- MESSAGES TABLE
-- ============================================
-- Stores chat messages
-- room: Chat room identifier (e.g., "general", "broadcast-room-5")
-- user_id: NULL if anonymous message
-- is_anonymous: 1 = anonymous, 0 = identified user
-- timestamp: When message was sent
-- anonymous_username: Name shown for anonymous messages
CREATE TABLE IF NOT EXISTS messages (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  content TEXT NOT NULL,
  room TEXT NOT NULL,
  user_id INTEGER,
  is_anonymous BOOLEAN NOT NULL DEFAULT 0,
  timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
  anonymous_username TEXT,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

-- ============================================
-- USER_CHATROOMS TABLE
-- ============================================
-- Stores user-created chat rooms
-- creator_id: User who created the chatroom
-- title: Name of the chatroom
-- password: Optional password protection
-- allow_anonymous: 1 = allow anonymous messages, 0 = logged in only
-- background_color: Custom background color (hex)
-- font_color: Custom text color (hex)
CREATE TABLE IF NOT EXISTS user_chatrooms (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    creator_id INTEGER NOT NULL,
    title TEXT NOT NULL,
    password TEXT,
    allow_anonymous BOOLEAN NOT NULL DEFAULT 1,
    background_color TEXT,
    font_color TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    last_active_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (creator_id) REFERENCES users(id)
);

-- ============================================
-- PRODUCTS TABLE
-- ============================================
-- Stores products for e-commerce
-- store_type: 'main' = main store, 'user' = user's personal store
-- user_id: NULL for main store, user ID for personal stores
CREATE TABLE IF NOT EXISTS MainHubUpgradeV001ForProducts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    subtitle TEXT,
    description TEXT,
    price REAL,
    image_url TEXT,
    store_type TEXT NOT NULL CHECK(store_type IN ('main', 'user')) DEFAULT 'main',
    user_id INTEGER,
    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- ============================================
-- CART_ITEMS TABLE
-- ============================================
-- Stores shopping cart items
-- quantity: How many of this product in cart
CREATE TABLE IF NOT EXISTS MainHubUpgradeV001ForCartItems (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    product_id INTEGER NOT NULL,
    quantity INTEGER NOT NULL DEFAULT 1,
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (product_id) REFERENCES MainHubUpgradeV001ForProducts(id)
);

-- ============================================
-- BROADCASTS TABLE
-- ============================================
-- Stores broadcast channels (like podcasts/live streams)
-- Each user can create multiple broadcasts
CREATE TABLE IF NOT EXISTS MainHubUpgradeV001ForBroadcasts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    name TEXT NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- ============================================
-- EPISODES TABLE
-- ============================================
-- Stores episodes within a broadcast
-- broadcast_id: Which broadcast this episode belongs to
-- media_url: URL to video/audio file
-- scheduled_at: When episode was scheduled to air
CREATE TABLE IF NOT EXISTS MainHubUpgradeV001ForEpisodes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    broadcast_id INTEGER NOT NULL,
    name TEXT NOT NULL,
    subtitle TEXT,
    description TEXT,
    media_url TEXT NOT NULL,
    cover_image_url TEXT,
    scheduled_at DATETIME,
    FOREIGN KEY (broadcast_id) REFERENCES MainHubUpgradeV001ForBroadcasts(id)
);

-- ============================================
-- EPISODE_IMAGES TABLE
-- ============================================
-- Stores multiple images per episode
CREATE TABLE IF NOT EXISTS MainHubUpgradeV001ForEpisodeImages (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    episode_id INTEGER NOT NULL,
    image_url TEXT NOT NULL,
    FOREIGN KEY (episode_id) REFERENCES MainHubUpgradeV001ForEpisodes(id)
);

-- ============================================
-- EPISODE_TAGS TABLE
-- ============================================
-- Stores tags/categories for episodes (searchable)
CREATE TABLE IF NOT EXISTS MainHubUpgradeV001ForEpisodeTags (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    episode_id INTEGER NOT NULL,
    tag TEXT NOT NULL,
    FOREIGN KEY (episode_id) REFERENCES MainHubUpgradeV001ForEpisodes(id)
);

-- ============================================
-- REPORTS TABLE
-- ============================================
-- Stores user reports for moderation
-- reported_id: NULL if reporting content instead of user
-- images: JSON array of screenshot URLs
CREATE TABLE IF NOT EXISTS reports (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    reporter_id INTEGER NOT NULL,
    reported_id INTEGER,
    reason TEXT NOT NULL,
    images TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (reporter_id) REFERENCES users(id),
    FOREIGN KEY (reported_id) REFERENCES users(id)
);
```

---

## Feature Implementation Details

### 1. SIGNUP & LOGIN (Authentication)

#### File: `server/auth.ts`

**What Happens During Signup:**

```typescript
// Step 1: User submits signup form with: username, password, email, phoneNumber
POST /api/auth/signup

// Step 2: Server validates input
if (!username || !password || !email || !phoneNumber) {
  return 400 error
}

// Step 3: Check if user already exists
SELECT * FROM users 
WHERE username = finalUsername 
  OR email = email 
  OR phone_number = phoneNumber

// Step 4: Hash password (bcrypt - never store plain text!)
hashedPassword = bcrypt.hash(password, 10)

// Step 5: Insert new user into database
INSERT INTO users (username, password, email, phone_number)
VALUES (uJohn, $2a$10$..., user@example.com, +1234567890)

// Step 6: Create JWT token (expires in 24 hours)
token = jwt.sign({ userId: 5, username: 'uJohn' }, SECRET_KEY, { expiresIn: '1d' })

// Step 7: Set token in httpOnly cookie (secure, can't be accessed by JavaScript)
res.cookie('token', token, { httpOnly: true, secure: true, sameSite: 'strict' })

// Step 8: Return user data
return { id: 5, username: 'uJohn' }
```

**What Happens During Login:**

```typescript
// Step 1: User submits login form with: username, password
POST /api/auth/login

// Step 2: Find user in database
SELECT * FROM users WHERE username = 'uJohn'

// Step 3: Compare provided password with stored hash
bcrypt.compare(providedPassword, storedHash) // returns true/false

// Step 4-8: Same as signup (create token, set cookie, return user data)
```

**JWT Token Explanation:**
- JWT = JSON Web Token (like a tamper-proof ticket)
- Contains: user ID, username, expiration time
- Signed with SECRET_KEY so it can't be forged
- Sent in httpOnly cookie so frontend can't access it (security feature!)
- When user makes authenticated request, the cookie is automatically sent

### 2. FRIENDS & FRIEND REQUESTS

#### File: `server/friends.ts`

**How Friend Requests Work:**

```typescript
// Step 1: User A sends friend request to User B
POST /api/friends/request
body: { userId: 2 }  // User B's ID

// Step 2: Database normalization (prevent duplicates)
// Always store smaller ID first: if IDs are 2 and 5, store as (2,5) not (5,2)
const [user_id1, user_id2] = [1, 2].sort((a, b) => a - b)

// Step 3: Check if request already exists
SELECT * FROM friends 
WHERE user_id1 = 1 AND user_id2 = 2

// Step 4: If not exists, insert with status 'pending'
INSERT INTO friends (user_id1, user_id2, status)
VALUES (1, 2, 'pending')

// Result: User B now sees pending request from User A
```

**Accept Friend Request:**

```typescript
// User B accepts User A's request
POST /api/friends/accept
body: { requestId: 5 }  // ID of the friend request record

// Step 1: Update status from 'pending' to 'accepted'
UPDATE friends SET status = 'accepted'
WHERE id = 5 AND user_id2 = 2  // Only user_id2 can accept

// Result: Users are now friends! Can see each other in friends list
```

**Get Friends List:**

```typescript
// Get all accepted friends for logged-in user
GET /api/friends

// Step 1: Find all friend relationships where status = 'accepted'
SELECT * FROM friends
WHERE status = 'accepted'
  AND (user_id1 = 5 OR user_id2 = 5)  // 5 is current user

// Step 2: Extract friend IDs (opposite ID in relationship)
friendIds = [2, 3, 4]  // IDs of friends

// Step 3: Get friend details
SELECT id, username, profile_image_url FROM users
WHERE id IN (2, 3, 4)

// Result: Array of friend objects with username, profile image
```

### 3. CHAT & MESSAGING

#### File: `server/chat.ts` (Socket.IO Real-time Communication)

**How Chat Works (Uses WebSocket):**

```typescript
// Step 1: User connects to chat server
socket.io connection established

// Step 2: User joins a room
socket.emit('joinRoom', 'broadcast-room-5')

// Step 3: Server loads last 50 messages from database
SELECT * FROM messages 
WHERE room = 'broadcast-room-5' 
ORDER BY timestamp ASC 
LIMIT 50

// Step 4: Messages sent to user
socket.emit('loadMessages', [{
  id: 1,
  content: "Hello!",
  username: "uJohn",
  timestamp: "2024-01-15T10:30:00Z"
}])

// Step 5: User sends new message
socket.emit('sendMessage', {
  room: 'broadcast-room-5',
  content: "Hi everyone!",
  isAnonymous: false
})

// Step 6: Server saves message to database
INSERT INTO messages (content, room, user_id, is_anonymous, anonymous_username)
VALUES ("Hi everyone!", 'broadcast-room-5', 5, 0, null)

// Step 7: Broadcast to all users in room (real-time!)
io.to('broadcast-room-5').emit('receiveMessage', {
  id: 42,
  content: "Hi everyone!",
  username: "uJohn",
  timestamp: "2024-01-15T10:31:00Z"
})

// All connected users in that room see the message instantly!
```

**Anonymous Messages:**
- User can send messages without logging in
- `is_anonymous = 1` in database
- Username shown as `anonymous_username` or "Anonymous"
- Can't see who sent anonymous messages

### 4. PRODUCTS & SHOPPING

#### Schema: `MainHubUpgradeV001ForProducts` & `MainHubUpgradeV001ForCartItems`

**Get All Products:**

```typescript
// Get main store products
SELECT * FROM MainHubUpgradeV001ForProducts
WHERE store_type = 'main'
ORDER BY price ASC

// Get user's store products
SELECT * FROM MainHubUpgradeV001ForProducts
WHERE store_type = 'user' AND user_id = 5
```

**Add to Cart:**

```typescript
INSERT INTO MainHubUpgradeV001ForCartItems 
(user_id, product_id, quantity)
VALUES (5, 10, 2)
// User 5 has product 10 in cart, quantity 2
```

### 5. BROADCASTS & EPISODES

#### Schema: `MainHubUpgradeV001ForBroadcasts`, `MainHubUpgradeV001ForEpisodes`, etc.

**Create Broadcast:**

```typescript
// User creates a broadcast channel
INSERT INTO MainHubUpgradeV001ForBroadcasts (user_id, name)
VALUES (5, "John's Podcast")
```

**Add Episode:**

```typescript
// Add episode to broadcast
INSERT INTO MainHubUpgradeV001ForEpisodes 
(broadcast_id, name, description, media_url, cover_image_url)
VALUES (3, "Episode 1", "My first episode", "https://...", "https://...")
```

---

## Docker Container Setup

### Dockerfile (How Container is Built)

The application runs in Docker with this setup:

```dockerfile
# Container name: mainuhubfeaturev001
# Port mapping: 4000 (inside container) â†’ exposed to Nginx
# Volume: /home/app/data â†’ SQLite database storage
# Environment: NODE_ENV=production
```

### Starting the Container

```bash
# SSH into Hostinger VPS
ssh username@your-hostinger-ip

# Navigate to app directory
cd /home/app

# Build and run container
docker build -t mainuhubfeaturev001 .
docker run -d \
  --name mainuhubfeaturev001 \
  -p 4000:4000 \
  -e NODE_ENV=production \
  -e DATA_DIRECTORY=/home/app/data \
  -v /home/app/data:/home/app/data \
  mainuhubfeaturev001
```

### Checking Container Status

```bash
# See if container is running
docker ps

# Check container logs
docker logs mainuhubfeaturev001

# Access container shell
docker exec -it mainuhubfeaturev001 bash

# Stop container
docker stop mainuhubfeaturev001

# Restart container
docker restart mainuhubfeaturev001
```

---

## Nginx Reverse Proxy Configuration

### What Nginx Does:
- Listens on ports 80 (HTTP) and 443 (HTTPS)
- Receives traffic from your domain
- Forwards requests to Express server inside Docker on port 4000
- Handles SSL certificates for HTTPS

### Nginx Configuration File

```nginx
# Location: /etc/nginx/sites-available/mainuhubfeaturev001

upstream express_app {
    # Connect to Docker container running on port 4000
    server localhost:4000;
}

# Redirect HTTP to HTTPS
server {
    listen 80;
    server_name yourdomain.com www.yourdomain.com;
    return 301 https://$server_name$request_uri;
}

# Main HTTPS configuration
server {
    listen 443 ssl http2;
    server_name yourdomain.com www.yourdomain.com;

    # SSL certificates (from Let's Encrypt)
    ssl_certificate /etc/letsencrypt/live/yourdomain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/yourdomain.com/privkey.pem;

    # SSL security settings
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;

    # Enable gzip compression
    gzip on;
    gzip_types text/plain text/css text/xml text/javascript 
               application/x-javascript application/xml+rss 
               application/javascript application/json;

    # Proxy settings for normal HTTP requests
    location / {
        proxy_pass http://express_app;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Special configuration for Socket.IO (chat)
    location /socket.io {
        proxy_pass http://express_app/socket.io;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
```

### Enable Nginx Configuration

```bash
# Create symlink to enable the site
sudo ln -s /etc/nginx/sites-available/mainuhubfeaturev001 \
           /etc/nginx/sites-enabled/mainuhubfeaturev001

# Test Nginx configuration
sudo nginx -t

# If test passes, reload Nginx
sudo systemctl reload nginx
```

---

## Application Flow Examples

### Example 1: User Signs Up

```
1. User opens browser, navigates to yourdomain.com
2. Nginx receives request on port 80
3. Nginx redirects to HTTPS (port 443)
4. Nginx forwards to Express on port 4000
5. Express serves React frontend (built HTML/JavaScript)
6. React frontend loads in browser
7. User fills signup form and clicks "Sign Up"
8. React sends POST request to /api/auth/signup
9. Express receives request, validates input
10. Express checks if user exists in SQLite database
11. Express hashes password with bcrypt
12. Express inserts new user record into users table
13. Express generates JWT token
14. Express sets token in httpOnly cookie
15. Express returns {id, username} as JSON
16. React receives response, stores user info, redirects to home
17. âœ… User is now signed up and logged in!
```

**Related Database Query:**
```sql
INSERT INTO users (username, password, email, phone_number)
VALUES ('uJohn', '$2a$10$...hashed_password...', 'john@example.com', '+1234567890')
```

### Example 2: User Sends Friend Request

```
1. User is logged in (has token in cookie)
2. User sees another user's profile
3. User clicks "Add Friend" button
4. React sends POST to /api/friends/request with friend's user ID
5. Express middleware (authenticate) verifies JWT token
6. Express extracts current user's ID from token
7. Express normalizes IDs (smaller first)
8. Express checks if request already exists
9. Express inserts into friends table with status='pending'
10. Express returns success message
11. React shows "Friend request sent!"
12. Recipient sees pending friend request in their notifications
```

**Related Database Queries:**
```sql
-- Check if request exists
SELECT * FROM friends 
WHERE user_id1 = 1 AND user_id2 = 5

-- Insert new request (doesn't exist)
INSERT INTO friends (user_id1, user_id2, status)
VALUES (1, 5, 'pending')

-- Recipient gets pending requests
SELECT f.id, f.user_id1, u.username, u.profile_image_url
FROM friends f
JOIN users u ON u.id = f.user_id1
WHERE f.user_id2 = 5 AND f.status = 'pending'
```

### Example 3: User Joins Chat Room

```
1. User clicks on chat room
2. React establishes WebSocket connection via Socket.IO
3. Socket.IO authentication middleware verifies JWT token
4. Socket.IO client emits 'joinRoom' event
5. Express Socket.IO server receives event
6. Express queries database for last 50 messages
7. Express sends messages to client
8. React displays chat history
9. Other users in room see "User joined" notification
10. User types message and presses Enter
11. React emits 'sendMessage' event with message content
12. Express receives event, saves to messages table
13. Express broadcasts message to all users in room
14. All users see message in real-time (< 1 second)
```

**Related Database Queries:**
```sql
-- Load chat history
SELECT id, content, user_id, is_anonymous, timestamp, anonymous_username
FROM messages
WHERE room = 'broadcast-room-5'
ORDER BY timestamp ASC
LIMIT 50

-- Save new message
INSERT INTO messages (content, room, user_id, is_anonymous, anonymous_username, timestamp)
VALUES ('Hi everyone!', 'broadcast-room-5', 5, 0, NULL, CURRENT_TIMESTAMP)
```

---

## Deployment Verification Checklist

### Before Going Live:

- [ ] Docker container builds without errors: `docker build -t mainuhubfeaturev001 .`
- [ ] Container starts successfully: `docker run -d --name mainuhubfeaturev001 ...`
- [ ] Database file created: `ls -la /home/app/data/database.sqlite`
- [ ] Database has tables: `sqlite3 /home/app/data/database.sqlite ".tables"`
- [ ] Nginx configuration is valid: `sudo nginx -t`
- [ ] Nginx is running: `sudo systemctl status nginx`
- [ ] Can access app via domain: `curl https://yourdomain.com`
- [ ] Frontend loads: Check browser, see React app
- [ ] API works: `curl https://yourdomain.com/api/auth/me`
- [ ] Can signup: Test in browser
- [ ] Can login: Test in browser
- [ ] Can add friend: Test in browser
- [ ] Chat works: Join room and send message
- [ ] Check logs for errors: `docker logs mainuhubfeaturev001`

### Monitoring:

```bash
# Watch real-time logs
docker logs -f mainuhubfeaturev001

# Check if container is using too much memory
docker stats mainuhubfeaturev001

# Check database file size
du -h /home/app/data/database.sqlite

# Backup database
cp /home/app/data/database.sqlite /backups/database.sqlite.backup
```

### Troubleshooting:

| Issue | Solution |
|-------|----------|
| "Connection refused" | Ensure Docker container is running: `docker ps` |
| "Cannot find module" | Rebuild container: `docker build -t mainuhubfeaturev001 .` |
| "Database locked" | SQLite is in use, restart container: `docker restart mainuhubfeaturev001` |
| "Socket.IO not working" | Check Nginx `/socket.io` location block is configured |
| "Pages load but no data" | Check database tables exist: `sqlite3 database.sqlite ".tables"` |

---

## Database Backup & Maintenance

### Regular Backups

```bash
# Backup database
cp /home/app/data/database.sqlite /backups/database-$(date +%Y%m%d).sqlite

# Compress backup
gzip /backups/database-20240115.sqlite
```

### Check Database Integrity

```bash
# SSH into container
docker exec -it mainuhubfeaturev001 bash

# Run SQLite integrity check
sqlite3 /home/app/data/database.sqlite "PRAGMA integrity_check;"

# Should return "ok"
```

### View Database Content

```bash
# SSH into container
docker exec -it mainuhubfeaturev001 bash

# Connect to database
sqlite3 /home/app/data/database.sqlite

# Common commands
.tables                    # List all tables
.schema users             # Show users table structure
SELECT COUNT(*) FROM users; # Count users
SELECT * FROM users LIMIT 5; # View first 5 users
.exit                     # Exit SQLite
```

---

## Security Best Practices

### Passwords:
- âœ… All passwords hashed with bcrypt (10 rounds)
- âœ… Never stored in plain text
- âœ… Never logged or displayed

### Authentication:
- âœ… JWT tokens expire in 24 hours
- âœ… Tokens stored in httpOnly cookies (JavaScript can't access)
- âœ… Cookies marked as secure (only sent over HTTPS)

### Database:
- âœ… Using parameterized queries (prevents SQL injection)
- âœ… Foreign key constraints prevent orphaned data
- âœ… Unique constraints prevent duplicate accounts

### API:
- âœ… All authenticated endpoints check JWT token
- âœ… CORS configured to allow only your domain
- âœ… Rate limiting recommended (not yet implemented)

---

## Environment Variables (In Docker)

These are set when container starts:

```bash
NODE_ENV=production              # Production mode (HTTPS required)
PORT=4000                        # Express server port
DATA_DIRECTORY=/home/app/data    # SQLite database location
JWT_SECRET=your-secret-key       # Token signing key (set via .env or docker run -e)
VITE_PORT=3000                   # Development only, ignored in production
```

---

## Performance Optimization

### SQLite Tips:
- SQLite is very fast for 1000s of users
- For 100k+ users, consider PostgreSQL (scalability)
- Current setup can handle 10,000+ concurrent messages/day

### Docker Tips:
- Monitor memory: `docker stats`
- Keep container logs: `docker logs --tail 100`
- Restart policy: `--restart=always` (auto-restart if crashes)

### Nginx Tips:
- Enable gzip compression (already configured)
- Enable HTTP/2 (already configured)
- Cache static assets with far-future headers

---

## Support & Debugging

### Get Help With:
- Check Express logs: `docker logs mainuhubfeaturev001`
- Check Nginx logs: `sudo tail -f /var/log/nginx/error.log`
- Connect to database: `sqlite3 /home/app/data/database.sqlite`
- Test API endpoint: `curl -X POST http://localhost:4000/api/auth/me`

### Common Log Messages:

```
âœ… "API Server running on port 4000" = Good! Server started
âœ… "A user connected" = User joined chat
âœ… "[query] select * from users..." = Normal database operation
âŒ "SQLITE_CANTOPEN" = Database file permissions issue
âŒ "EADDRINUSE" = Port 4000 already in use
```

---

## Next Steps

1. **Test Everything**: Go through deployment checklist above
2. **Set Up Monitoring**: Monitor container and database
3. **Create Admin User**: Add first user for testing all features
4. **Set Up SSL**: Ensure HTTPS is working
5. **Document API**: Write API documentation for team
6. **Plan Scaling**: If getting 10k+ users, plan migration to PostgreSQL

---

## Summary

Your application is now:
- âœ… Running in Docker container on Hostinger VPS
- âœ… Behind Nginx reverse proxy for HTTP/HTTPS
- âœ… Using SQLite database at `/home/app/data/database.sqlite`
- âœ… Supporting user signup/login with JWT authentication
- âœ… Supporting friend requests and friend lists
- âœ… Supporting real-time chat via Socket.IO
- âœ… Supporting e-commerce products and shopping cart
- âœ… Supporting broadcasts and episodes
- âœ… All data persisted in SQLite

Everything is connected and ready to use! ðŸŽ‰
